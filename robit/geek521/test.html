<div class="cbody">
<div>
 <p>
  <strong>
   （问题一：什么叫垃圾回收机制？）
  </strong>
   垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄露。
  <br />
  <strong>
   （问题二：java的垃圾回收有什么特点？）
  </strong>
   JAVA语言不允许程序员直接控制内存空间的使用。内存空间的分配和回收都是由JRE负责在后台自动进行的，尤其是无用内存空间的回收操作 (garbagecollection,也称垃圾回收)，只能由运行环境提供的一个超级线程进行监测和控制。
  <br />
  <strong>
   （问题三：垃圾回收器什么时候会运行？）
  </strong>
   一般是在CPU空闲或空间不足时自动进行垃圾回收，而程序员无法精确控制垃圾回收的时机和顺序等。
  <br />
  <strong>
   （问题四：什么样的对象符合垃圾回收条件？）
  </strong>
   当没有任何获得线程能访问一个对象时，该对象就符合垃圾回收条件。
  <br />
  <strong>
   （问题五：垃圾回收器是怎样工作的？）
  </strong>
   垃圾回收器如发现一个对象不能被任何活线程访问时，他将认为该对象符合删除条件，就将其加入回收队列，但不是立即销毁对象，何时销毁并释放内存是无法预知的。垃圾回收不能强制执行，然而Java提供了一些方法（如：System.gc()方法），允许你请求JVM执行垃圾回收，而不是要求，虚拟机会尽其所能满足请求，但是不能保证JVM从内存中删除所有不用的对象。（该方法我试过了，的确有些时候是释放不了内存的）
  <br />
  <strong>
   （问题六：一个java程序能够耗尽内存吗？）
  </strong>
   可以。垃圾收集系统尝试在对象不被使用时把他们从内存中删除。然而，如果保持太多活的对象，系统则可能会耗尽内存。垃圾回收器不能保证有足够的内存，只能保证可用内存尽可能的得到高效的管理。
  <br />
  <strong>
   （问题七：如何显示的使对象符合垃圾回收条件？）
  </strong>
   
  <br />
  （1） 空引用 ：当对象没有对他可到达引用时，他就符合垃圾回收的条件。也就是说如果没有对他的引用，删除对象的引用就可以达到目的，因此我们可以把引用变量设置为 null，来符合垃圾回收的条件。(实际上我对下列的方法差不多都试过，发现垃圾回收不是迅速执行的，它会有一个缓慢的过程。)
  <br />
  Java代码 
  <br />
  StringBuffer sb = new StringBuffer(&quot;hello&quot;);   
  <br />
  System.out.println(sb);   
  <br />
  sb=null;  
  <br />
  （2） 重新为引用变量赋值：可以通过设置引用变量引用另一个对象来解除该引用变量与一个对象间的引用关系。
 </p>
 <p>
  Java代码 
  <br />
  StringBuffer sb1 = new StringBuffer(&quot;hello&quot;);   
  <br />
  StringBuffer sb2 = new StringBuffer(&quot;goodbye&quot;);   
  <br />
  System.out.println(sb1);   
  <br />
  sb1=sb2;//此时&quot;hello&quot;符合回收条件  
  <br />
  StringBuffer sb1 = new StringBuffer(&quot;hello&quot;);
  <br />
  StringBuffer sb2 = new StringBuffer(&quot;goodbye&quot;);
  <br />
  System.out.println(sb1);
  <br />
  sb1=sb2;//此时&quot;hello&quot;符合回收条件
 </p>
 <p>
  （3） 方法内创建的对象：所创建的局部变量仅在该方法的作用期间内存在。一旦该方法返回，在这个方法内创建的对象就符合垃圾收集条件。有一种明显的例外情况，就是方法的返回对象。（如果调用的类终止后，其中的私有变量应该也会被释放）
  <br />
  Java代码 
  <br />
  public static void main(String[] args) {   
  <br />
          Date d = getDate();   
  <br />
          System.out.println(&quot;d = &quot; + d);   
  <br />
  }   
  <br />
  private static Date getDate() {   
  <br />
          Date d2 = new Date();   
  <br />
          StringBuffer now = new StringBuffer(d2.toString());   
  <br />
          System.out.println(now);   
  <br />
          return d2;   
  <br />
  }  
  <br />
  public static void main(String[] args) {
  <br />
          Date d = getDate();
  <br />
          System.out.println(&quot;d = &quot; + d);
  <br />
  }
  <br />
  private static Date getDate() {
  <br />
          Date d2 = new Date();
  <br />
          StringBuffer now = new StringBuffer(d2.toString());
  <br />
          System.out.println(now);
  <br />
          return d2;
  <br />
  } 
 </p>
 <p>
  （4） 隔离引用：这种情况中，被回收的对象仍具有引用，这种情况称作隔离岛。若存在这两个实例，他们互相引用，并且这两个对象的所有其他引用都删除，其他任何线程无法访问这两个对象中的任意一个。也可以符合垃圾回收条件。
  <br />
  Java代码 
  <br />
  public class Island {   
  <br />
          Island i;   
  <br />
          public static void main(String[] args) {   
  <br />
                  Island i2 = new Island();   
  <br />
                  Island i3 = new Island();   
  <br />
                  Island i4 = new Island();   
  <br />
                  i2.i=i3;   
  <br />
                  i3.i=i4;   
  <br />
                  i4.i=i2;   
  <br />
                  i2=null;   
  <br />
                  i3=null;   
  <br />
                  i4=null;   
  <br />
          }   
  <br />
  }  
 </p>
 <p>
  public class Island {
  <br />
          Island i;
  <br />
          public static void main(String[] args) {
  <br />
                  Island i2 = new Island();
  <br />
                  Island i3 = new Island();
  <br />
                  Island i4 = new Island();
  <br />
                  i2.i=i3;
  <br />
                  i3.i=i4;
  <br />
                  i4.i=i2;
  <br />
                  i2=null;
  <br />
                  i3=null;
  <br />
                  i4=null;
  <br />
          }
  <br />
  }
 </p>
 <p>
  <strong>
   （问题八：垃圾收集前进行清理 ------finalize()方法）
  </strong>
   java提供了一种机制，使你能够在对象刚要被垃圾回收之前运行一些代码。这段代码位于名为finalize()的方法内，所有类从Object类继承这个方法。由于不能保证垃圾回收器会删除某个对象。因此放在finalize()中的代码无法保证运行。因此建议不要重写finalize();
 </p>
</div>
<br />
<br />
<a href="http://zyp307.iteye.com/blog/2157316#comments">
 已有
 <strong>
  0
 </strong>
 人发表留言，猛击-&gt;&gt;
 <strong>
  这里
 </strong>
 &lt;&lt;-参与讨论
</a>
<br />
<br />
<br />
ITeye推荐
<br />
<ul>
 <li>
  <a href="http://www.iteye.com/clicks/433" target="_blank">
   —软件人才免语言低担保 赴美带薪读研！—
  </a>
 </li>
</ul>
<br />
<br />
<br />
</div>